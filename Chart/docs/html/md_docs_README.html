<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WeaChart: Source code Description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WeaChart
   &#160;<span id="projectnumber">1.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Source code Description </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Subjects</h2>
<p>The <b>WeaChart</b> component is divded into four main areas:</p>
<ul>
<li><a href="#ui/styles">UI/Styles</a></li>
<li><a href="#opengl-and-renderer">OpenGL and Renderer</a></li>
<li><a href="#backend">Backend</a> <h2>- <a href="#cmake-library-configs">CMake library Configs</a> </h2>
</li>
</ul>
<h2>UI/Styles</h2>
<p>All of the components UIs are written in <b>QML</b>, except for the main chart scene, which is implemented using <b>shaders</b>. The grids and axes are drawn using the <b>canvas</b>.</p>
<h3>QML</h3>
<p>The main component is <b>GLChartFrame</b>. Users only need to use this component to load the chart. An optional component is <b>GLLegend</b>; NOTE that <b>GLItemLegend</b> should be avoided as a public component.</p>
<h3>GLChartFrame</h3>
<ul>
<li>As you can see <code>GLChartFrame</code>, everything is user-defined, so we need many properties, as listed below. <div class="fragment"><div class="line">property bool useGrid: true</div><div class="line">property int decimalPlaces: 2</div><div class="line">property int majorXCount: 7 // Number of X major Grid</div><div class="line">property int majorYCount: 7 // Number of Y major Grid</div><div class="line">property int minorPerMajor: 4 // Number of sub grids per each majorGrid.</div><div class="line">property color majorColor: &quot;#666&quot;</div><div class="line">property color minorColor: &quot;#aaa&quot;</div><div class="line">property color axisColor: &quot;black&quot;</div><div class="line">property color backgroundColor: &quot;blue&quot;</div><div class="line">property real backgroundOpacity: 0.3</div><div class="line">property string xTitle: &quot;X Axis&quot;</div><div class="line">property string yTitle: &quot;Y Axis&quot;</div><div class="line">property int xTitlePosY: root.height - 5</div><div class="line">property int yTitlePosX: 0</div><div class="line">property font titleFont: Qt.font({ pixelSize: 13, bold: true})</div><div class="line">property color titleColor: &quot;black&quot;</div><div class="line">property font labelFont: Qt.font({ pixelSize: 11})</div><div class="line">property color labelColor: &quot;black&quot;</div><div class="line">property string xLabelSuffix: &quot;&quot; // For example xLabelSuffix: &quot;$&quot;, then value from 100.0 goes to 100.0$</div><div class="line">property string yLabelSuffix: &quot;&quot; // Same as xLabelSuffix</div><div class="line"></div><div class="line">property int leftMargin: 40</div><div class="line">property int rightMargin: 20</div><div class="line">property int bottomMargin: 30</div><div class="line">property int topMargin: 20</div><div class="line"></div><div class="line">// Mouse Buttons</div><div class="line">property int selectPointsMouseButton: Qt.LeftButton // See mouseItemSelect id for more detail</div><div class="line">property int selectViewMouseButton: Qt.RightButton // See mouseItemView id for more detail</div><div class="line"></div><div class="line">// ReadOnly</div><div class="line">property var chart: glChartView</div><div class="line"></div><div class="line">// Chart Properties</div><div class="line">property real minX: 0</div><div class="line">property real maxX: 10.0</div><div class="line">property real minY: 0</div><div class="line">property real maxY: 10.0</div><div class="line">property bool limitView: false // Limiting view with MinX &amp; MaxX and ...</div><div class="line">property real velocityCoefficient: 0.91</div><div class="line">property int panMouseButton: Qt.MiddleButton</div></div><!-- fragment --></li>
<li>The next step is drawing the chart's background structures, such as grids and axes. <a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/qml/GLChartFrame.qml#L75-L149">view canvas code</a></li>
<li>Drawing labels &amp; numerical factors is much easier with Repeater instead canvas. Here is the code: <div class="fragment"><div class="line">// Labels for major X</div><div class="line">Repeater {</div><div class="line">    model: majorXCount + 1</div><div class="line">    delegate: Text {</div><div class="line">        x: root.leftMargin + index * ((root.width - root.leftMargin - root.rightMargin) / root.majorXCount)</div><div class="line">        y: root.height - root.bottomMargin + 4</div><div class="line">        color: root.labelColor</div><div class="line">        font: root.labelFont</div><div class="line">        text: (glChartView.projLeft + index * ((glChartView.projRight - glChartView.projLeft)</div><div class="line">                                               / root.majorXCount)).toFixed(decimalPlaces) + root.xLabelSuffix</div><div class="line">    }</div><div class="line">}</div><div class="line">// Labels for major Y</div><div class="line">Repeater {</div><div class="line">    model: majorYCount + 1</div><div class="line">    delegate: Text {</div><div class="line">        x: 0 + (root.leftMargin * 0.55)</div><div class="line">        y: root.topMargin + index * ((root.height - root.topMargin - root.bottomMargin) / root.majorYCount) - 8</div><div class="line">        color: root.labelColor</div><div class="line">        font: root.labelFont</div><div class="line">        text: (glChartView.projTop - index * ((glChartView.projTop - glChartView.projBottom)</div><div class="line">                                              / root.majorYCount)).toFixed(decimalPlaces) + root.yLabelSuffix</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">// X Title</div><div class="line">Text {</div><div class="line">    anchors.horizontalCenter: parent.horizontalCenter</div><div class="line">    y: root.xTitlePosY</div><div class="line">    color: root.titleColor</div><div class="line">    font: root.titleFont</div><div class="line">    text: root.xTitle</div><div class="line">}</div><div class="line">// Y Title</div><div class="line">Text {</div><div class="line">    anchors.verticalCenter: parent.verticalCenter</div><div class="line">    x: root.yTitlePosX</div><div class="line">    rotation: -90</div><div class="line">    horizontalAlignment: Qt.AlignLeft</div><div class="line">    verticalAlignment: Qt.AlignBottom</div><div class="line">    color: root.titleColor</div><div class="line">    font: root.titleFont</div><div class="line">    text: root.yTitle</div><div class="line">}</div></div><!-- fragment --></li>
<li>Now, we need to connect the property-changed signals (used in canvas Paint) to the <b>canvas.requestPaint()</b>. <div class="fragment"><div class="line">onUseGridChanged: canvas.requestPaint()</div><div class="line">onMajorXCountChanged: canvas.requestPaint()</div><div class="line">onMajorYCountChanged: canvas.requestPaint()</div><div class="line">onMinorPerMajorChanged: canvas.requestPaint()</div><div class="line">onMajorColorChanged: canvas.requestPaint()</div><div class="line">onMinorColorChanged: canvas.requestPaint()</div><div class="line">onBackgroundColorChanged: canvas.requestPaint()</div><div class="line">onBackgroundOpacityChanged: canvas.requestPaint()</div></div><!-- fragment --></li>
<li>It is better to ensure that the properties with <code>mouseButton</code> types do not have the same values as each other.</li>
</ul>
<div class="fragment"><div class="line">// CLOSE program if any of these properties values has the same value.</div><div class="line">Component.onCompleted: {</div><div class="line">    if (root.panMouseButton === root.selectPointsMouseButton ||</div><div class="line">            root.selectPointsMouseButton === root.selectViewMouseButton ||</div><div class="line">            root.panMouseButton === root.selectViewMouseButton)</div><div class="line">    {</div><div class="line">        console.log(&quot;[ERROR]: At GLChartFrame QML, panMouseButton, selectPointsMouseButton, selectViewMouseButton, can&#39;t be same button!.&quot;)</div><div class="line">        Qt.exit(1)</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><ul>
<li>Let's place the <code><a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView</a></code> component in the canvas chart scene area. Then we assign ChartProperties to itself. <div class="fragment"><div class="line">GLChartView {</div><div class="line">    id: glChartView</div><div class="line">    anchors.fill: canvas</div><div class="line">    anchors.topMargin: root.topMargin</div><div class="line">    anchors.bottomMargin: root.bottomMargin</div><div class="line">    anchors.rightMargin: root.rightMargin</div><div class="line">    anchors.leftMargin: root.leftMargin</div><div class="line"></div><div class="line">    background.opacity: 0.0 // Custom Prop</div><div class="line">    background.color: Qt.rgba(0, 0, 0, 0) // Custom Prop</div><div class="line">    axisRange.minX: root.minX // Custom Prop</div><div class="line">    axisRange.maxX: root.maxX // Custom Prop</div><div class="line">    axisRange.minY: root.minY // Custom Prop</div><div class="line">    axisRange.maxY: root.maxY // Custom Prop</div><div class="line">    limitView: root.limitView // Custom Prop</div><div class="line">    velocityCoefficient: root.velocityCoefficient</div><div class="line">    panMouseButton: root.panMouseButton</div><div class="line">}</div></div><!-- fragment --></li>
</ul>
<h3>GLItemLegend</h3>
<p>A single legendItem which drawn using the <b>Canvas</b>, and the shape of its marker matches with <b>SeriesType(scatter, line, area)</b>.</p>
<p><a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/qml/GLItemLegend.qml">view GLItemLegend for more detail</a></p>
<h3>GLLegend</h3>
<p>The main legend component is represented with <b>Repeater</b>, which automatically adds all series into a single legend item. The idea behind this item is to provide a simple component that helps implement the visual representation of the legend, simply by adding it to the <b>GLChartFrame</b> component.</p>
<p><a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/qml/GLLegend.qml">view GLLegend for more detail</a></p>
<h3>QML Files</h3>
<ul>
<li><a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/qml/GLChartFrame.qml">GLChartFrame.qml</a></li>
<li><a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/qml/GLItemLegend.qml">GLItemLegend.qml</a></li>
<li><a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/qml/GLLegend.qml">GLLegend.qml</a></li>
</ul>
<h3>Events</h3>
<p>First of all, let's handle the zoom and pan events. For this, we need to go back to the <code><a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView</a></code> class, because it contains those events. Since no drawing is requried, it is much easier to handle them in the <b>FBO(<a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView</a></b> directly.</p>
<h4>UI events include:</h4>
<ul>
<li><a href="#zoom-event">Zoom Event</a></li>
<li><a href="#pan-event">Pan Event</a></li>
<li><a href="#select-event">Select Event</a></li>
<li><a href="#multiselect-event">Multiselect Event</a></li>
<li><a href="#crop-event">Crop Event</a></li>
</ul>
<h4>Zoom Event</h4>
<p><em><b>Arguments:</b></em></p><ol type="1">
<li>mxPixel: float =&gt; Mouse x position unit by pixel.</li>
<li>myPixel: float =&gt; Mouse y position unit by pixel.</li>
<li>angleDeltaY: float =&gt; Mouse angleDeltaY value unit by pixel.</li>
<li>zoomX: bool =&gt; If its false, means xAxis zoom will be ignore.</li>
<li>zoomY: bool =&gt; If its false, means yAxis zoom will be ignore.</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classGLChartView.html#a6ff1f650d11f8c5eeb4b089e47196b3a">GLChartView::adjustView</a>(<span class="keywordtype">float</span> mxPixel, <span class="keywordtype">float</span> myPixel, <span class="keywordtype">float</span> angleDeltaY,</div><div class="line">                             <span class="keywordtype">bool</span> zoomX, <span class="keywordtype">bool</span> zoomY)</div><div class="line">{</div><div class="line">    constexpr <span class="keywordtype">float</span> zoomFactor = 0.15f;</div><div class="line">    <span class="keywordtype">float</span> factor = (angleDeltaY &gt; 0) ? (1 - zoomFactor) : (1 + zoomFactor);</div><div class="line">    <span class="keywordtype">float</span> minX = m_proj.<a class="code" href="structProjection.html#aaec190719ba0ff81875a8687ab2a1c85">left</a>;</div><div class="line">    <span class="keywordtype">float</span> maxX = m_proj.<a class="code" href="structProjection.html#ae98c4df18ec332100bc211c18e4a403c">right</a>;</div><div class="line">    <span class="keywordtype">float</span> minY = m_proj.<a class="code" href="structProjection.html#a4baf7e82a69193c33c243a8271666e91">bottom</a>;</div><div class="line">    <span class="keywordtype">float</span> maxY = m_proj.<a class="code" href="structProjection.html#ac8c26d922bf0037adf895ea2760cef43">top</a>;</div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> mx = <a class="code" href="classGLChartView.html#a0b0291bc990dff6d3ec7ce34ff8d2979">normXtoWorld</a>(mxPixel);</div><div class="line">    <span class="keywordtype">float</span> my = <a class="code" href="classGLChartView.html#a1f9f798a0262cb5cfaf845c022813ef0">normYtoWorld</a>(myPixel);</div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> newMinX = mx - (mx - minX) * factor;</div><div class="line">    <span class="keywordtype">float</span> newMaxX = mx + (maxX - mx) * factor;</div><div class="line">    <span class="keywordtype">float</span> newMinY = my - (my - minY) * factor;</div><div class="line">    <span class="keywordtype">float</span> newMaxY = my + (maxY - my) * factor;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (m_limitView &amp;&amp;</div><div class="line">        (newMinX &lt; m_axisRange-&gt;minX() ||</div><div class="line">         newMaxX &gt; m_axisRange-&gt;<a class="code" href="classPropertyAxisRange.html#a13d3e3a5afc6511c9232d9529889c472">maxX</a>() ||</div><div class="line">         newMinY &lt; m_axisRange-&gt;<a class="code" href="classPropertyAxisRange.html#a43226f71f73ec90308a1d85b059a02e8">minY</a>() ||</div><div class="line">         newMaxY &gt; m_axisRange-&gt;<a class="code" href="classPropertyAxisRange.html#abf7b6852bd4af9cb92850c9c1c468ac4">maxY</a>()))</div><div class="line">    {</div><div class="line">        <a class="code" href="classGLChartView.html#a541d13c6cf04aeb846464be4f6c9dd0f">updateAxisRange</a>();</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (zoomX) {</div><div class="line">        m_proj.<a class="code" href="structProjection.html#aaec190719ba0ff81875a8687ab2a1c85">left</a> = newMinX;</div><div class="line">        m_proj.<a class="code" href="structProjection.html#ae98c4df18ec332100bc211c18e4a403c">right</a> = newMaxX;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (zoomY) {</div><div class="line">        m_proj.<a class="code" href="structProjection.html#a4baf7e82a69193c33c243a8271666e91">bottom</a> = newMinY;</div><div class="line">        m_proj.<a class="code" href="structProjection.html#ac8c26d922bf0037adf895ea2760cef43">top</a> = newMaxY;</div><div class="line">    }</div><div class="line"></div><div class="line">    emit <a class="code" href="classGLChartView.html#a2e4fb76069e21b84e663ab8deef3a49b">updateQml</a>();</div><div class="line"></div><div class="line">    update();</div><div class="line">}</div></div><!-- fragment --><p>&gt;[!INFO] </p><blockquote class="doxtable">
<p>If you're wondering when <code>m_proj</code> comes from, refer <a href="#opengl-and-renderer">OpenGL and Renderer</a> </p>
</blockquote>
<h4>PAN Event</h4>
<p><em><b>class Members:</b></em></p><ol type="1">
<li>bool m_panning = false; =&gt; This field will be set true when mouse is <b>pressed</b> and its true until the mouse <b>released</b>.</li>
<li>QPointF m_panVelocity; =&gt; Current panning velocity to having smooth panning release.</li>
<li>QPointF m_lastMousePos; =&gt; Required for pan calculation.</li>
<li>QElapsedTimer m_panElaps; =&gt; To decrease <code>m_panVelocity</code> automatically, this field is required to calculate how much value <code>m_panVelocity</code>, should minus.</li>
<li>int m_panTimerId = -1; =&gt; TimerId required, because we are using QObject <code>timerEvent</code> method.</li>
</ol>
<p><em><b>class Properties:</b></em></p><ol type="1">
<li>bool m_limitView = false; =&gt; If its true the panning should be disabled.</li>
<li>qreal velocityCoefficient = 0.91; =&gt; Constant factor which multiple with <code>m_panVelocity</code>. (0 means no velocity)</li>
<li>Qt::MouseButton panMouseButton = Qt::MiddleButton; =&gt; Recognize which button is for panning process and which buttons are not.</li>
</ol>
<p><b>Starting Pan</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classGLChartView.html#a8640531861b674199b9b2c9b2e54fd2e">GLChartView::mousePressEvent</a>(QMouseEvent *event)</div><div class="line">{</div><div class="line">    <span class="comment">// PAN Process</span></div><div class="line">    <span class="keywordflow">if</span> (event-&gt;button() == <a class="code" href="classGLChartView.html#a121be122aeae9dbf5a1d914c85279bab">panMouseButton</a> &amp;&amp; !m_limitView) {</div><div class="line">        m_panning = <span class="keyword">true</span>;</div><div class="line">        m_lastMousePos = <span class="keyword">event</span>-&gt;pos();</div><div class="line">        m_panVelocity = QPointF(0, 0);</div><div class="line">        <span class="comment">// If auto pan after released wasn&#39;t finish yet, kill that process.</span></div><div class="line">        <span class="keywordflow">if</span> (m_panTimerId != -1) {</div><div class="line">            killTimer(m_panTimerId);</div><div class="line">            m_panTimerId = -1;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><b>Panning...</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classGLChartView.html#a0d806d0da961e9d7e26e444cf1b4990d">GLChartView::mouseMoveEvent</a>(QMouseEvent *event)</div><div class="line">{</div><div class="line">    <span class="comment">// PAN Process</span></div><div class="line">    <span class="keywordflow">if</span> (m_panning) {</div><div class="line">        <span class="keywordtype">float</span> lastX = <a class="code" href="classGLChartView.html#a0b0291bc990dff6d3ec7ce34ff8d2979">normXtoWorld</a>(m_lastMousePos.x());</div><div class="line">        <span class="keywordtype">float</span> lastY = <a class="code" href="classGLChartView.html#a1f9f798a0262cb5cfaf845c022813ef0">normYtoWorld</a>(m_lastMousePos.y());</div><div class="line">        <span class="keywordtype">float</span> curX = <a class="code" href="classGLChartView.html#a0b0291bc990dff6d3ec7ce34ff8d2979">normXtoWorld</a>(event-&gt;pos().x());</div><div class="line">        <span class="keywordtype">float</span> curY = <a class="code" href="classGLChartView.html#a1f9f798a0262cb5cfaf845c022813ef0">normYtoWorld</a>(event-&gt;pos().y());</div><div class="line"></div><div class="line">        qreal dt = m_panElaps.restart() / 1000.0;</div><div class="line">        QPointF delta((curX - lastX), (curY - lastY));</div><div class="line">        m_lastMousePos = <span class="keyword">event</span>-&gt;pos();</div><div class="line"></div><div class="line">        m_proj.<a class="code" href="structProjection.html#aaec190719ba0ff81875a8687ab2a1c85">left</a> -= delta.x();</div><div class="line">        m_proj.<a class="code" href="structProjection.html#ae98c4df18ec332100bc211c18e4a403c">right</a> -= delta.x();</div><div class="line">        m_proj.<a class="code" href="structProjection.html#a4baf7e82a69193c33c243a8271666e91">bottom</a> -= delta.y();</div><div class="line">        m_proj.<a class="code" href="structProjection.html#ac8c26d922bf0037adf895ea2760cef43">top</a> -= delta.y();</div><div class="line"></div><div class="line">        m_panVelocity = delta / dt;</div><div class="line"></div><div class="line">        emit <a class="code" href="classGLChartView.html#a2e4fb76069e21b84e663ab8deef3a49b">updateQml</a>(); <span class="comment">// updating labels number values.</span></div><div class="line"></div><div class="line">        update();</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><b>Releasing Pan's MouseButton</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classGLChartView.html#a3b445b5bf4ec3a0a1f713804ef6ee42a">GLChartView::mouseReleaseEvent</a>(QMouseEvent *event)</div><div class="line">{</div><div class="line">    <span class="comment">// PAN Process</span></div><div class="line">    <span class="keywordflow">if</span> (event-&gt;button() == <a class="code" href="classGLChartView.html#a121be122aeae9dbf5a1d914c85279bab">panMouseButton</a> &amp;&amp; !m_limitView) {</div><div class="line">        m_panning = <span class="keyword">false</span>;</div><div class="line">        m_panElaps.restart();</div><div class="line">        <span class="keywordflow">if</span> (m_panTimerId == -1) {</div><div class="line">            m_panTimerId = startTimer(16); <span class="comment">// Start PAN deceleration ramp timer.</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><b>Pan Ramp</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classGLChartView.html#a0a1100db58d86d25a60988471fe330dc">GLChartView::timerEvent</a>(QTimerEvent *event)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (event-&gt;timerId() == m_panTimerId)</div><div class="line">        panAcceleration();</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> GLChartView::panAcceleration() {</div><div class="line"></div><div class="line"><span class="comment">//    constexpr double friction = 0.91; // Velocity Friction.</span></div><div class="line">    qreal dt = m_panElaps.restart() / 1000.0;</div><div class="line"></div><div class="line">    m_proj.<a class="code" href="structProjection.html#aaec190719ba0ff81875a8687ab2a1c85">left</a> -= m_panVelocity.x() * dt;</div><div class="line">    m_proj.<a class="code" href="structProjection.html#ae98c4df18ec332100bc211c18e4a403c">right</a> -= m_panVelocity.x() * dt;</div><div class="line">    m_proj.<a class="code" href="structProjection.html#a4baf7e82a69193c33c243a8271666e91">bottom</a> -= m_panVelocity.y() * dt;</div><div class="line">    m_proj.<a class="code" href="structProjection.html#ac8c26d922bf0037adf895ea2760cef43">top</a> -= m_panVelocity.y() * dt;</div><div class="line"></div><div class="line">    m_panVelocity *= <a class="code" href="classGLChartView.html#ac850b8fd11247dcb0a18181c88d1bfe3">velocityCoefficient</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (qAbs(m_panVelocity.x()) &lt; 0.03 &amp;&amp; qAbs(m_panVelocity.y() &lt; 0.03)) {</div><div class="line">        killTimer(m_panTimerId);</div><div class="line">        m_panTimerId = -1;</div><div class="line">    }</div><div class="line"></div><div class="line">    emit <a class="code" href="classGLChartView.html#a2e4fb76069e21b84e663ab8deef3a49b">updateQml</a>();</div><div class="line">    update();</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> <hr/>
<p> Back to the QML events.</p>
<h4>Single XY Axes Zoom Event</h4>
<p>The reason i included this in QML is that the event must be called in the <b>canvas</b> area, not in the <b><a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView</a></b> area.</p>
<div class="fragment"><div class="line">// Single X Axis Zoom</div><div class="line">MouseArea {</div><div class="line">    id: mouseWheelXAxis</div><div class="line">    anchors.fill: canvas</div><div class="line">    anchors.topMargin: glChartView.height + root.topMargin</div><div class="line">    onWheel: (mouse) =&gt;</div><div class="line">             {</div><div class="line">                 glChartView.adjustView(glChartView.width / 2, 0, mouse.angleDelta.y, // x, y, angleDelta.y</div><div class="line">                                                 true, false) // zoomX, zoomY</div><div class="line">             }</div><div class="line">}</div><div class="line">// Single Y Axis Zoom</div><div class="line">MouseArea {</div><div class="line">    id: mouseWheelYAxis</div><div class="line">    anchors.fill: canvas</div><div class="line">    anchors.rightMargin: glChartView.width + root.rightMargin</div><div class="line">    anchors.bottomMargin: root.bottomMargin</div><div class="line">    onWheel: (mouse) =&gt;</div><div class="line">             {</div><div class="line">                 glChartView.adjustView(0, glChartView.height / 2, mouse.angleDelta.y, // x, y, angelDelta.y</div><div class="line">                                                 false, true) // zoomX, zoomY</div><div class="line">             }</div><div class="line">}</div></div><!-- fragment --><h4>Select Event</h4>
<p>Before describing the select event, we need to draw a rubber recantgle for visulization. This rectangle will also be used in the <b>Crop Event</b>.</p>
<div class="fragment"><div class="line">// Rubber Band rectangle</div><div class="line">Rectangle {</div><div class="line">    id: rectRubBand</div><div class="line">    visible: mouseItemSelect.selecting | mouseItemView.selecting</div><div class="line">    // Drawing Rectangle with scaled positions</div><div class="line">    function rubberBand(mouse, startPos) {</div><div class="line">        let x = Math.max(Math.min(mouse.x, startPos.x), leftMargin)</div><div class="line">        let y = Math.max(Math.min(mouse.y, startPos.y), topMargin)</div><div class="line">        let w = Math.abs(Math.max(x, mouse.x) - startPos.x)</div><div class="line">        let h = Math.abs(Math.max(y, mouse.y) - startPos.y)</div><div class="line">        rectRubBand.x = x</div><div class="line">        rectRubBand.y = y</div><div class="line">        rectRubBand.width = x + w &gt;= canvas.width - rightMargin ? canvas.width - rightMargin - x : w</div><div class="line">        rectRubBand.height = y + h &gt;= canvas.height - bottomMargin ? canvas.height - bottomMargin - y : h</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>and now here is the <b>Select Event</b>:</p>
<div class="fragment"><div class="line">// Selection RubberBand</div><div class="line">MouseArea {</div><div class="line">    property point startPos</div><div class="line">    property bool selecting: false</div><div class="line">    id: mouseItemSelect</div><div class="line">    anchors.fill: canvas</div><div class="line">    acceptedButtons: root.selectPointsMouseButton</div><div class="line"></div><div class="line"></div><div class="line">    onPressed: (mouse) =&gt;</div><div class="line">               {</div><div class="line">                   // Disable Mouse View</div><div class="line">                   mouseItemView.enabled = false</div><div class="line"></div><div class="line">                   startPos = Qt.point(mouse.x, mouse.y)</div><div class="line">                   selecting = true</div><div class="line">                   rectRubBand.x = startPos.x</div><div class="line">                   rectRubBand.y = startPos.y</div><div class="line">                   rectRubBand.width = 0</div><div class="line">                   rectRubBand.height = 0</div><div class="line"></div><div class="line">                   // Rect Style</div><div class="line">                   rectRubBand.color = Qt.rgba(0, 120/255, 215/255, 0.3)</div><div class="line">                   rectRubBand.border.color = &quot;#0078d7&quot;</div><div class="line">                   rectRubBand.border.width = 1</div><div class="line"></div><div class="line">                   glChartView.preSelect(!(mouse.modifiers &amp; Qt.ControlModifier))</div><div class="line"></div><div class="line">               }</div><div class="line"></div><div class="line">    onPositionChanged: {</div><div class="line">        if (!selecting)</div><div class="line">            return</div><div class="line">        rectRubBand.rubberBand(mouse, startPos)</div><div class="line">        glChartView.rangeSelecting(Qt.rect(rectRubBand.x - leftMargin,</div><div class="line">                                           rectRubBand.y - topMargin,</div><div class="line">                                           rectRubBand.width,</div><div class="line">                                           rectRubBand.height))</div><div class="line"></div><div class="line">    }</div><div class="line">    onReleased: {</div><div class="line">        selecting = false</div><div class="line"></div><div class="line">        if (!rectRubBand.width &amp;&amp; !rectRubBand.height) {</div><div class="line">            rectRubBand.rubberBand(mouse, startPos)</div><div class="line">            glChartView.rangeSelecting(Qt.rect(rectRubBand.x - leftMargin - 2,</div><div class="line">                                               rectRubBand.y - topMargin - 2,</div><div class="line">                                               5, // Width</div><div class="line">                                               5)) // Height</div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">        glChartView.selectFinished()</div><div class="line"></div><div class="line">        // Enable Mouse View</div><div class="line">        mouseItemView.enabled = true</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h4>Multiselect Event</h4>
<p>It's simple, just you need to pass the <code>Qt.ControlModifier</code> to the <code>glChartView.preSelect</code> method.</p>
<h4>Crop Event</h4>
<p>Same as the <b>Select Event</b>, just need to create a visual rubberBand and passing the <code>topLeft</code>, <code>bottomRight</code> fields to <b>glChartView</b>.</p>
<div class="fragment"><div class="line">// View Selection RubberBand</div><div class="line">MouseArea {</div><div class="line">    property point startPos</div><div class="line">    property bool selecting: false</div><div class="line">    id: mouseItemView</div><div class="line">    anchors.fill: canvas</div><div class="line">    acceptedButtons: root.selectViewMouseButton</div><div class="line">    onPressed: (mouse) =&gt;</div><div class="line">               {</div><div class="line">                   // Disable Mouse Selecting</div><div class="line">                   mouseItemSelect.enabled = false</div><div class="line"></div><div class="line">                   startPos = Qt.point(mouse.x, mouse.y)</div><div class="line">                   selecting = true</div><div class="line">                   rectRubBand.x = startPos.x</div><div class="line">                   rectRubBand.y = startPos.y</div><div class="line">                   rectRubBand.width = 0</div><div class="line">                   rectRubBand.height = 0</div><div class="line"></div><div class="line">                   // Rect Style</div><div class="line">                   rectRubBand.color = Qt.rgba(215/255, 10/255, 0, 0.05)</div><div class="line">                   rectRubBand.border.color = &quot;#d73800&quot;</div><div class="line">                   rectRubBand.border.width = 1</div><div class="line">               }</div><div class="line"></div><div class="line">    onPositionChanged: {</div><div class="line">        if (!selecting)</div><div class="line">            return</div><div class="line">        rectRubBand.rubberBand(mouse, startPos)</div><div class="line">    }</div><div class="line">    onReleased: {</div><div class="line">        selecting = false</div><div class="line">        glChartView.updateRectView(Qt.rect(rectRubBand.x - leftMargin,</div><div class="line">                                           rectRubBand.y - topMargin,</div><div class="line">                                           rectRubBand.width,</div><div class="line">                                           rectRubBand.height))</div><div class="line"></div><div class="line">        // Enable Mouse Selecting</div><div class="line">        mouseItemSelect.enabled = true</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>OpenGL and Renderer</h2>
<p>To keep my explanation simple, I won't go into the details of the FBO and backgrounds. I'll only cover important parts and content. Keep in mind that in <b><a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView(FBO)</a></b>, I only store the properties that need to be synchronized with the <b><a class="el" href="classGLChartRenderer.html" title="Chart renderer based on QQuickFramebufferObject::Renderer. ">GLChartRenderer</a></b>. So, there are no calculations in the FBO except for the <b><a class="el" href="structProjection.html" title="OpenGL projection matrix. ">Projection(m_proj)</a></b>.</p>
<h3><a class="el" href="structProjection.html" title="OpenGL projection matrix. ">Projection</a></h3>
<p>m_proj is an attribute with four variables: <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>. These fields are initialized with the default values provided by the <code>axisRange</code> property. Note that the projection works like a camera, allowing us to change the view of objects instead of moving all the points. This means that with each <b>PAN</b> and <b>Zoom</b> movement, the <code>m_proj</code> variables must be updated.</p>
<h3>Renderer</h3>
<p>A basic renderer with a single <b>shaderProgram</b>, <b>VAO</b> and <b>VBO</b>. The VBO accepts a <code>vec2</code> for position and a <code>vec4</code> for the color attribute. I pass the <code>seletedRanges</code> positions as a uniform array, and in the shader, I check each point to see if it is within the <code>selectedRanges</code>. If it is, the point's color is set to yellow.</p>
<p>There is also a <b>SSBO</b> in the shaderProgram. It is an array of struct(each struct stores series properties and the start/end index in the <b>VBO</b> <a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/include/WeaChart/utils/GLStructures.h#L24">see SeriesProps struct</a>) By passing this <b>SSBO</b>, I can easily determine which vertex belongs to which series. Knowing this, I can assign the style of that vertex, such as <code>SeriesType</code>, <code>BaseColor</code> and so on.</p>
<h3>Shaders</h3>
<p>I recommend to read the <a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/shaders/">chart.vert &amp; chart.frag</a> files, as there is nothing confusing in their content. </p><hr/>
<h2>Backend</h2>
<p>To develop a flexible and standard chart backend, we need to provide three main components:</p><ol type="1">
<li>Independent series.</li>
<li>A series read/write handler.</li>
<li>A main scene that combines series data and properties into a single raw dataset.</li>
</ol>
<p>The key idea is designing a series class with a templated Point structure.</p>
<p><b>Why a templated point?</b> Normally, we only need x, y, and color for each point, so why use a template?</p>
<p>The answer is that you may have additional data for each point thtat is not directly related to the chart scene, but you may want to use those fields when a point is <b>selected</b>. That is the reason we need a templated Point.</p>
<h3>Series Backend</h3>
<h4><a class="el" href="classGLAbstractSeries.html" title="Abstract series class (it can&#39;t be create as object). Creation idea of this class is: Because the GLS...">GLAbstractSeries</a> &amp; <a class="el" href="classGLSeriesStorage.html" title="Template series class based on GLAbstractSeries. THe GLSeriesStorage works like a vector...">GLSeriesStorage</a> development</h4>
<p>You should know that it isn't possible to create a class with both a <b>template</b> and <b>Q_OBJECT</b> at the same time (so we can't use signals for the selection process directly in the templated class).</p>
<p>To support both, I created an abstract series class (<code><a class="el" href="classGLAbstractSeries.html" title="Abstract series class (it can&#39;t be create as object). Creation idea of this class is: Because the GLS...">GLAbstractSeries</a></code>) that contains virtual methods and a <code>makeSelectVariant</code> method. This method should be called from the main scene's (<code><a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView</a></code>) selection process, where we emit <code>selected</code> signal. <a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/include/WeaChart/series/GLAbstractSeries.h">see GLAbstractSeries</a></p>
<p>After that, I wrote a templated class that inherits from the abstract class. In this class(<code><a class="el" href="classGLSeriesStorage.html" title="Template series class based on GLAbstractSeries. THe GLSeriesStorage works like a vector...">GLSeriesStorage</a></code>), we override the virtual methods and implement the point appending process, the <code>makeSelectVariant</code> method, and so on. <a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/include/WeaChart/series/GLSeriesStorage.h">see GLSeriesStorage</a></p>
<p><b>Note</b> that this templated series class works like a <code>QVector&lt;T&gt;</code>, <b>T</b> must inherit from <code><a class="el" href="structPointXYBase.html" title="Base chart&#39;s point struct. ">PointXYBase</a></code>.</p>
<p>Up to this point, I haven't explained how and where <code>select</code> signal is triggered. I've only described the series structure and the prerequisites for the <code>selectProcess</code>.</p>
<h4><a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView</a> &amp; GLSeriesHandler</h4>
<p>As you know, there is no direct way to add a <code><a class="el" href="classGLSeriesStorage.html" title="Template series class based on GLAbstractSeries. THe GLSeriesStorage works like a vector...">GLSeriesStorage</a>&lt;T&gt;</code> to the <code><a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView</a></code> series vector. The solution is simple: C++ allows passing child classes as their parent class type. For example, the argument of the <code>addSeries</code> method can be of type <code><a class="el" href="classGLAbstractSeries.html" title="Abstract series class (it can&#39;t be create as object). Creation idea of this class is: Because the GLS...">GLAbstractSeries</a></code> instead of <code><a class="el" href="classGLSeriesStorage.html" title="Template series class based on GLAbstractSeries. THe GLSeriesStorage works like a vector...">GLSeriesStorage</a></code>.</p>
<p>To read/write the <code><a class="el" href="classGLSeriesStorage.html" title="Template series class based on GLAbstractSeries. THe GLSeriesStorage works like a vector...">GLSeriesStorage</a></code> data and emit <code>selected</code> signal from <code><a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView</a></code>, a handler class is needed(<a href="http://172.16.50.13/parsa/qcustommodels/-/blob/main/Chart/include/WeaChart/series/GLSeriesHandler.h">GLSeriesHandler</a>). This class provides a getter(which returns the <code><a class="el" href="classGLSeriesStorage.html" title="Template series class based on GLAbstractSeries. THe GLSeriesStorage works like a vector...">GLSeriesStorage</a></code>(named as view())) and <code>emitselected</code> function, inside of which the <code>selected</code> signal of <code><a class="el" href="classGLSeriesStorage.html" title="Template series class based on GLAbstractSeries. THe GLSeriesStorage works like a vector...">GLSeriesStorage</a></code> is emitted.</p>
<p><b>Note:</b> By using the <b>GLSeriesHandler</b> inside of the <b><a class="el" href="classGLChartView.html" title="An FBO class provides the UIs and the logics of the Chart scene. ">GLChartView</a></b>, you can probably access to all of the <b><a class="el" href="classGLAbstractSeries.html" title="Abstract series class (it can&#39;t be create as object). Creation idea of this class is: Because the GLS...">GLAbstractSeries</a></b> public slots. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
